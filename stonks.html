<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Strategic War Game v6</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      background: #111;
      color: #fff;
      font-family: 'Orbitron', Arial, sans-serif;
      overflow: hidden;
    }
    canvas {
      border: 2px solid #555;
      width: 100vw;
      height: 100vh;
      display: block;
      touch-action: none;
      background: linear-gradient(180deg, #1a1a1a, #2a2a2a);
    }
    #status-overlay {
      position: absolute;
      top: 15px;
      left: 15px;
      background: rgba(0, 0, 0, 0.8);
      padding: 12px;
      border-radius: 8px;
      font-size: 16px;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
      border: 1px solid #444;
      max-width: calc(100vw - 30px);
      max-height: calc(100vh - 30px);
    }
    #action-indicator {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 8px 15px;
      border-radius: 8px;
      font-size: 18px;
      color: #ffd700;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
      max-width: calc(100vw - 30px);
    }
    #error-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: red;
      font-size: 18px;
      text-align: center;
      display: none;
      max-width: calc(100vw - 30px);
    }
    @media (max-width: 600px) {
      #status-overlay {
        font-size: 12px;
        padding: 8px;
        top: 10px;
        left: 10px;
      }
      #action-indicator {
        font-size: 14px;
        padding: 6px 10px;
        bottom: 10px;
      }
      #error-message {
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="status-overlay">
    <p>Gold: <span id="gold">100</span> | Enemy Gold: <span id="enemyGold">100</span> | Area: <span id="area">0%</span> | Status: <span id="status">Playing</span></p>
    <p>Drones: <span id="playerDrones">0</span> | Turrets: <span id="playerTurrets">0</span> | Destroyed: You <span id="playerUnitsDestroyed">0</span>, Enemy <span id="enemyUnitsDestroyed">0</span></p>
  </div>
  <div id="action-indicator"></div>
  <div id="error-message"></div>
  <script>
let grid = [];
let terrain = [];
let gridCols, gridRows;
let cellWidth, cellHeight;
let totalCells;
let playerUnits = [];
let enemyUnits = [];
let gold = 100;
let enemyGold = 100;
let controlledCells = 0;
let gameStatus = 'Playing';
let gameHistory = [];
let enemyDroneHealth = 75;
let enemySpawnProbs = { drone: 0.6, turret: 0.4 };
let spawnFlash = null;
let shotEffects = [];
let missileEffects = [];
let deathEffects = [];
let playerUnitsDestroyed = 0;
let enemyUnitsDestroyed = 0;
let invalidPlacementMessage = null;
let lastDebugLog = 0;
let inputActive = false;
let inputStartTime = null;
let inputX, inputY;
let playerGradient, enemyGradient, rockGradient, treeGradient;
let terrainCache = [];
let lastUnitPositions = [];
let isVerticalSplit = false;

function setup() {
  try {
    let canvas = createCanvas(window.innerWidth, window.innerHeight);
    canvas.parent(document.body);
    canvas.style('display', 'block');
    pixelDensity(1);
    background(30);
    // Calculate grid dimensions based on screen aspect ratio
    let aspectRatio = window.innerWidth / window.innerHeight;
    isVerticalSplit = aspectRatio > 1; // Vertical split for wide screens, horizontal for tall/square
    // Aim for ~1024 cells, prefer even dimensions for clean split
    if (isVerticalSplit) {
      gridCols = Math.round(Math.sqrt(1024 * aspectRatio / 2)) * 2; // Even columns for vertical split
      gridRows = Math.round(1024 / gridCols);
    } else {
      gridRows = Math.round(Math.sqrt(1024 / aspectRatio / 2)) * 2; // Even rows for horizontal split
      gridCols = Math.round(1024 / gridRows);
    }
    totalCells = gridCols * gridRows;
    cellWidth = window.innerWidth / gridCols;
    cellHeight = window.innerHeight / gridRows;
    playerGradient = drawingContext.createLinearGradient(0, 0, cellWidth, cellHeight);
    playerGradient.addColorStop(0, 'rgba(255, 255, 0, 0.15)');
    playerGradient.addColorStop(1, 'rgba(200, 200, 0, 0.25)');
    enemyGradient = drawingContext.createLinearGradient(0, 0, cellWidth, cellHeight);
    enemyGradient.addColorStop(0, 'rgba(255, 0, 0, 0.15)');
    enemyGradient.addColorStop(1, 'rgba(200, 0, 0, 0.25)');
    rockGradient = drawingContext.createLinearGradient(-10, -10, 10, 10);
    rockGradient.addColorStop(0, 'rgba(120, 120, 120, 1)');
    rockGradient.addColorStop(1, 'rgba(80, 80, 80, 1)');
    treeGradient = drawingContext.createLinearGradient(-10, -10, 10, 10);
    treeGradient.addColorStop(0, 'rgba(0, 120, 0, 1)');
    treeGradient.addColorStop(1, 'rgba(0, 80, 0, 1)');
    console.log(`p5.js canvas initialized: ${width}x${height}, grid=${gridCols}x${gridRows}, cell=${cellWidth.toFixed(1)}x${cellHeight.toFixed(1)}, split=${isVerticalSplit ? 'vertical' : 'horizontal'}`);
    resetGame();
  } catch (e) {
    console.error('Error in setup:', e);
    document.getElementById('error-message').innerText = 'Failed to initialize game canvas. Please refresh and try again.';
    document.getElementById('error-message').style.display = 'block';
  }
}

function windowResized() {
  resizeCanvas(window.innerWidth, window.innerHeight);
  let aspectRatio = window.innerWidth / window.innerHeight;
  isVerticalSplit = aspectRatio > 1;
  if (isVerticalSplit) {
    gridCols = Math.round(Math.sqrt(1024 * aspectRatio / 2)) * 2;
    gridRows = Math.round(1024 / gridCols);
  } else {
    gridRows = Math.round(Math.sqrt(1024 / aspectRatio / 2)) * 2;
    gridCols = Math.round(1024 / gridRows);
  }
  totalCells = gridCols * gridRows;
  cellWidth = window.innerWidth / gridCols;
  cellHeight = window.innerHeight / gridRows;
  playerUnits.forEach(u => {
    let gridX = Math.floor(u.x / (width / gridCols));
    let gridY = Math.floor(u.y / (height / gridRows));
    u.x = gridX * cellWidth + cellWidth / 2;
    u.y = gridY * cellHeight + cellHeight / 2;
  });
  enemyUnits.forEach(u => {
    let gridX = Math.floor(u.x / (width / gridCols));
    let gridY = Math.floor(u.y / (height / gridRows));
    u.x = gridX * cellWidth + cellWidth / 2;
    u.y = gridY * cellHeight + cellHeight / 2;
  });
  cacheTerrain();
  resetGame();
}

function resetGame() {
  grid = [];
  terrain = [];
  terrainCache = [];
  playerUnits = [];
  enemyUnits = [];
  gold = 100;
  enemyGold = 100;
  controlledCells = 0;
  gameStatus = 'Playing';
  spawnFlash = null;
  shotEffects = [];
  missileEffects = [];
  deathEffects = [];
  playerUnitsDestroyed = 0;
  enemyUnitsDestroyed = 0;
  invalidPlacementMessage = null;
  lastDebugLog = 0;
  inputActive = false;
  inputStartTime = null;
  lastUnitPositions = [];
  // Initialize grid with split
  for (let i = 0; i < gridRows; i++) {
    grid[i] = [];
    terrain[i] = [];
    for (let j = 0; j < gridCols; j++) {
      if (isVerticalSplit) {
        grid[i][j] = j < gridCols / 2 ? 'player' : 'enemy';
      } else {
        grid[i][j] = i < gridRows / 2 ? 'player' : 'enemy';
      }
      terrain[i][j] = null;
      if (grid[i][j] === 'player') controlledCells++;
    }
  }
  let terrainCount = 0;
  let terrainTarget = Math.round(totalCells * 0.1);
  while (terrainCount < terrainTarget) {
    let x = Math.floor(random(gridCols));
    let y = Math.floor(random(gridRows));
    let startX = Math.floor(gridCols * 0.1), startY = Math.floor(gridRows * 0.1);
    let endX = Math.floor(gridCols * 0.9), endY = Math.floor(gridRows * 0.9);
    if (!terrain[y][x] && !(x >= startX && x <= startX + 6 && y >= startY && y <= startY + 6) && !(x >= endX - 6 && x <= endX && y >= endY - 6 && y <= endY)) {
      terrain[y][x] = random() < 0.5 ? 'R' : 'T';
      terrainCount++;
    }
  }
  // Place player units in player region
  if (isVerticalSplit) {
    playerUnits.push({ x: Math.floor(gridCols * 0.1) * cellWidth + cellWidth / 2, y: Math.floor(gridRows * 0.1) * cellHeight + cellHeight / 2, type: 'city', health: 500 });
    playerUnits.push({ x: Math.floor(gridCols * 0.2) * cellWidth + cellWidth / 2, y: Math.floor(gridRows * 0.2) * cellHeight + cellHeight / 2, type: 'bunker', health: 200 });
    playerUnits.push({ x: Math.floor(gridCols * 0.1) * cellWidth + cellWidth / 2, y: Math.floor(gridRows * 0.2) * cellHeight + cellHeight / 2, type: 'bunker', health: 200 });
    enemyUnits.push({ x: Math.floor(gridCols * 0.9) * cellWidth + cellWidth / 2, y: Math.floor(gridRows * 0.9) * cellHeight + cellHeight / 2, type: 'city', health: 500 });
    enemyUnits.push({ x: Math.floor(gridCols * 0.8) * cellWidth + cellWidth / 2, y: Math.floor(gridRows * 0.9) * cellHeight + cellHeight / 2, type: 'bunker', health: 200 });
    enemyUnits.push({ x: Math.floor(gridCols * 0.9) * cellWidth + cellWidth / 2, y: Math.floor(gridRows * 0.8) * cellHeight + cellHeight / 2, type: 'bunker', health: 200 });
  } else {
    playerUnits.push({ x: Math.floor(gridCols * 0.1) * cellWidth + cellWidth / 2, y: Math.floor(gridRows * 0.1) * cellHeight + cellHeight / 2, type: 'city', health: 500 });
    playerUnits.push({ x: Math.floor(gridCols * 0.2) * cellWidth + cellWidth / 2, y: Math.floor(gridRows * 0.2) * cellHeight + cellHeight / 2, type: 'bunker', health: 200 });
    playerUnits.push({ x: Math.floor(gridCols * 0.1) * cellWidth + cellWidth / 2, y: Math.floor(gridRows * 0.2) * cellHeight + cellHeight / 2, type: 'bunker', health: 200 });
    enemyUnits.push({ x: Math.floor(gridCols * 0.9) * cellWidth + cellWidth / 2, y: Math.floor(gridRows * 0.9) * cellHeight + cellHeight / 2, type: 'city', health: 500 });
    enemyUnits.push({ x: Math.floor(gridCols * 0.8) * cellWidth + cellWidth / 2, y: Math.floor(gridRows * 0.9) * cellHeight + cellHeight / 2, type: 'bunker', health: 200 });
    enemyUnits.push({ x: Math.floor(gridCols * 0.9) * cellWidth + cellWidth / 2, y: Math.floor(gridRows * 0.8) * cellHeight + cellHeight / 2, type: 'bunker', health: 200 });
  }
  spawnEnemy();
  cacheTerrain();
  loop();
}

function cacheTerrain() {
  terrainCache = [];
  for (let i = 0; i < gridRows; i++) {
    for (let j = 0; j < gridCols; j++) {
      if (terrain[i][j]) {
        terrainCache.push({ x: j * cellWidth + cellWidth / 2, y: i * cellHeight + cellHeight / 2, type: terrain[i][j] });
      }
    }
  }
}

function draw() {
  try {
    background(30);
    drawMap();
    updateUnits();
    playerUnits.forEach(u => drawUnit(u, color(255, 255, 0)));
    enemyUnits.forEach(u => drawUnit(u, color(255, 0, 0)));
    if (spawnFlash) {
      fill(255, 255, 0, 150);
      ellipse(spawnFlash.x, spawnFlash.y, min(cellWidth, cellHeight) * 0.5, min(cellWidth, cellHeight) * 0.5);
      spawnFlash.timer--;
      if (spawnFlash.timer <= 0) spawnFlash = null;
    }
    shotEffects.forEach(e => {
      stroke(e.color);
      strokeWeight(2);
      line(e.startX, e.startY, e.endX, e.endY);
      e.timer--;
    });
    shotEffects = shotEffects.filter(e => e.timer > 0).slice(-10);
    missileEffects.forEach(e => {
      if (e.type === 'trajectory') {
        stroke(255, 255, 255, 200);
        strokeWeight(3);
        line(e.startX, e.startY, e.endX, e.endY);
        e.timer--;
      } else if (e.type === 'explosion') {
        let alpha = map(e.timer, 0, 20, 0, 255);
        fill(255, e.stage === 0 ? 255 : e.stage === 1 ? 165 : 0, e.stage === 0 ? 255 : e.stage === 1 ? 0 : 0, alpha);
        ellipse(e.x, e.y, e.stage === 0 ? min(cellWidth, cellHeight) : e.stage === 1 ? min(cellWidth, cellHeight) * 1.5 : min(cellWidth, cellHeight) * 2);
        e.timer--;
        if (e.timer % 6 === 0) e.stage++;
      }
    });
    missileEffects = missileEffects.filter(e => e.timer > 0).slice(-2);
    deathEffects.forEach(e => {
      let alpha = map(e.timer, 0, 10, 0, 255);
      fill(255, e.stage === 0 ? 255 : e.stage === 1 ? 165 : 0, e.stage === 0 ? 255 : e.stage === 1 ? 0 : 0, alpha);
      ellipse(e.x, e.y, e.stage === 0 ? min(cellWidth, cellHeight) * 0.3 : e.stage === 1 ? min(cellWidth, cellHeight) * 0.8 : min(cellWidth, cellHeight) * 1.2);
      e.timer--;
      if (e.timer % 4 === 0) e.stage++;
    });
    deathEffects = deathEffects.filter(e => e.timer > 0).slice(-5);
    noStroke();
    strokeWeight(1);
    if (invalidPlacementMessage && invalidPlacementMessage.timer > 0) {
      fill(255, 0, 0);
      textSize(min(width, height) * 0.04);
      textAlign(CENTER);
      text(invalidPlacementMessage.text, width / 2, min(width, height) * 0.1);
      invalidPlacementMessage.timer--;
    }
    if (frameCount % 120 === 0) {
      if (unitsMoved()) revertNonAdjacentCells();
    }
    updateUI();
    generateGold();
    checkGameStatus();
    if (frameCount % 7200 === 0) {
      console.log(`Debug: frameCount=${frameCount}, FPS=${frameRate().toFixed(1)}, playerUnits=${playerUnits.length}, enemyUnits=${enemyUnits.length}, controlledCells=${controlledCells}, gameStatus=${gameStatus}`);
    }
  } catch (e) {
    console.error('Error in draw:', e);
    document.getElementById('error-message').innerText = 'Rendering error: ' + e.message;
    document.getElementById('error-message').style.display = 'block';
    console.log('Stopping game loop due to draw error');
    noLoop();
  }
}

function unitsMoved() {
  let moved = false;
  let newPositions = [];
  playerUnits.concat(enemyUnits).forEach(u => {
    newPositions.push({ id: u.id || `${u.x}-${u.y}-${u.type}`, x: u.x, y: u.y });
    let prev = lastUnitPositions.find(p => p.id === (u.id || `${u.x}-${u.y}-${u.type}`));
    if (prev && (Math.abs(u.x - prev.x) > 1 || Math.abs(u.y - prev.y) > 1)) moved = true;
  });
  lastUnitPositions = newPositions;
  return moved;
}

function mousePressed() {
  if (gameStatus !== 'Playing') return false;
  inputX = mouseX;
  inputY = mouseY;
  inputStartTime = millis();
  inputActive = true;
  return false;
}

function touchStarted() {
  if (gameStatus !== 'Playing' || touches.length !== 1) return false;
  inputX = touches[0].x;
  inputY = touches[0].y;
  inputStartTime = millis();
  inputActive = true;
  return false;
}

function mouseReleased() {
  if (gameStatus !== 'Playing' || !inputActive) return false;
  let holdDuration = millis() - inputStartTime;
  handleInput(inputX, inputY, holdDuration);
  inputActive = false;
  inputStartTime = null;
  return false;
}

function touchEnded() {
  if (gameStatus !== 'Playing' || !inputActive) return false;
  let holdDuration = millis() - inputStartTime;
  handleInput(inputX, inputY, holdDuration);
  inputActive = false;
  inputStartTime = null;
  return false;
}

function handleInput(inputX, inputY, holdDuration) {
  if (inputX < 0 || inputX > width || inputY < 0 || inputY > height) {
    invalidPlacementMessage = { text: 'Click within grid', timer: 200 };
    return false;
  }
  let gridX = Math.floor(inputX / cellWidth);
  let gridY = Math.floor(inputY / cellHeight);
  if (gridX < 0 || gridX >= gridCols || gridY < 0 || gridY >= gridRows) {
    invalidPlacementMessage = { text: 'Click within grid', timer: 200 };
    return false;
  }
  let x = gridX * cellWidth + cellWidth / 2;
  let y = gridY * cellHeight + cellHeight / 2;
  if (grid[gridY][gridX] === 'enemy' && gold >= 500) {
    let playerCity = playerUnits.find(u => u.type === 'city');
    if (playerCity) {
      gold -= 500;
      missileEffects.push({ type: 'trajectory', startX: playerCity.x, startY: playerCity.y, endX: x, endY: y, timer: 10 });
      missileEffects.push({ type: 'explosion', x: x, y: y, stage: 0, timer: 20 });
      playerUnits = playerUnits.filter(u => {
        if (dist(u.x, u.y, x, y) < min(cellWidth, cellHeight) && u.type !== 'city') {
          playerUnitsDestroyed++;
          return false;
        }
        return true;
      });
      enemyUnits = enemyUnits.filter(u => {
        if (dist(u.x, u.y, x, y) < min(cellWidth, cellHeight)) {
          enemyUnitsDestroyed++;
          return false;
        }
        return true;
      });
    } else {
      invalidPlacementMessage = { text: 'No city for missile', timer: 200 };
    }
  } else if (grid[gridY][gridX] === 'player' && !isUnitAtPosition(x, y) && terrain[gridY][gridX] !== 'R' && terrain[gridY][gridX] !== 'T') {
    let action = holdDuration > 500 ? 'turret' : 'drone';
    if (action === 'drone' && gold >= 40) {
      gold -= 40;
      playerUnits.push({ x, y, type: 'drone', health: 70, battery: 1800, patrolTarget: null, stuckCounter: 0 });
      spawnFlash = { x, y, timer: 20 };
    } else if (action === 'turret' && gold >= 200 && isValidTurretPosition(x, y)) {
      gold -= 200;
      playerUnits.push({ x, y, type: 'turret', health: 80, cooldown: 0 });
      spawnFlash = { x, y, timer: 20 };
    } else {
      invalidPlacementMessage = { text: `Cannot place ${action}: ${gold < (action === 'drone' ? 40 : 200) ? 'Low gold' : 'Invalid position'}`, timer: 200 };
    }
  } else {
    invalidPlacementMessage = { text: `Need yellow cell${gold < 500 && grid[gridY][gridX] === 'enemy' ? ', 500 gold for missile' : ''}`, timer: 200 };
  }
  return false;
}

function spawnEnemy(type = 'drone') {
  if (!['drone', 'turret'].includes(type) || enemyUnits.length >= 15) return;
  let x, y, attempts = 0;
  let isValidPosition = false;
  do {
    if (isVerticalSplit) {
      x = Math.floor(random(gridCols / 2, gridCols));
      y = Math.floor(random(gridRows));
    } else {
      x = Math.floor(random(gridCols));
      y = Math.floor(random(gridRows / 2, gridRows));
    }
    isValidPosition = grid[y][x] === 'enemy' && !isUnitAtPosition(x * cellWidth + cellWidth / 2, y * cellHeight + cellHeight / 2) && terrain[y][x] !== 'R' && terrain[y][x] !== 'T';
    attempts++;
  } while (!isValidPosition && attempts < 10);
  if (isValidPosition) {
    let unit = { 
      x: x * cellWidth + cellWidth / 2, 
      y: y * cellHeight + cellHeight / 2, 
      type, 
      health: type === 'drone' ? enemyDroneHealth : 80,
      battery: type === 'drone' ? 1800 : 0,
      patrolTarget: null,
      cooldown: type === 'turret' ? 0 : null,
      stuckCounter: 0
    };
    if (type === 'turret' && isValidTurretPosition(unit.x, unit.y, true)) {
      enemyUnits.push(unit);
    } else if (type === 'drone') {
      enemyUnits.push(unit);
    }
  }
}

function isUnitAtPosition(x, y) {
  return enemyUnits.some(u => dist(x, y, u.x, u.y) < min(cellWidth, cellHeight) * 0.3) || 
         playerUnits.some(u => dist(x, y, u.x, u.y) < min(cellWidth, cellHeight) * 0.3);
}

function isValidTurretPosition(x, y, isEnemy = false) {
  let gridX = Math.floor(x / cellWidth);
  let gridY = Math.floor(y / cellHeight);
  if (gridX < 0 || gridX >= gridCols || gridY < 0 || gridY >= gridRows || !grid[gridY]) return false;
  return grid[gridY][gridX] === (isEnemy ? 'enemy' : 'player') && !isUnitAtPosition(x, y) && terrain[gridY][gridX] !== 'R' && terrain[gridY][gridX] !== 'T';
}

function updateUnits() {
  playerUnits = playerUnits.filter(u => {
    if (u.health <= 0) {
      deathEffects.push({ x: u.x, y: u.y, type: 'explosion', stage: 0, timer: 10 });
      if (u.type === 'city') {
        gameStatus = 'Defeat!';
        console.log('Game stopped: Player city destroyed');
        setTimeout(() => {
          recordGameOutcome('enemy_win');
          noLoop();
        }, 2000);
        return false;
      } else if (u.type === 'bunker') {
        enemyGold += 50;
      } else {
        playerUnitsDestroyed++;
      }
      return false;
    }
    return u.type !== 'drone' || u.battery > 0;
  });
  enemyUnits = enemyUnits.filter(u => {
    if (u.health <= 0) {
      deathEffects.push({ x: u.x, y: u.y, type: 'explosion', stage: 0, timer: 10 });
      if (u.type === 'city') {
        gameStatus = 'Victory!';
        console.log('Game stopped: Enemy city destroyed');
        setTimeout(() => {
          recordGameOutcome('player_win');
          noLoop();
        }, 2000);
        return false;
      } else if (u.type === 'bunker') {
        gold += 50;
      } else {
        enemyUnitsDestroyed++;
      }
      return false;
    }
    return u.type !== 'drone' || u.battery > 0;
  });
  
  playerUnits.forEach(u => {
    if (u.type === 'drone') {
      u.battery -= 1;
      moveUnit(u);
    } else if (u.type === 'turret' && u.cooldown > 0) {
      u.cooldown--;
    }
  });
  
  enemyUnits.forEach(u => {
    if (u.type === 'drone') {
      u.battery -= 1;
      moveEnemy(u);
    } else if (u.type === 'turret' && u.cooldown > 0) {
      u.cooldown--;
    }
  });
}

function drawUnit(unit, col) {
  let pulse = 1 + 0.1 * Math.sin(frameCount * 0.1);
  let scale = min(cellWidth, cellHeight) / 40;
  if (unit.type === 'drone') {
    push();
    translate(unit.x, unit.y);
    let angle = unit.patrolTarget ? Math.atan2(unit.patrolTarget.y - unit.y, unit.patrolTarget.x - unit.x) : 0;
    rotate(angle);
    fill(col);
    ellipse(0, 0, 10 * pulse * scale, 10 * pulse * scale);
    let propSize = 5 * scale;
    let propOffset = 10 * scale;
    let propAngle = frameCount * 0.5;
    fill(150, 150, 150);
    for (let i = 0; i < 4; i++) {
      let propX = propOffset * cos(TWO_PI / 4 * i + propAngle);
      let propY = propOffset * sin(TWO_PI / 4 * i + propAngle);
      ellipse(propX, propY, propSize, propSize);
    }
    fill(unit.battery > 0 ? color(0, 255, 0) : color(255, 0, 0));
    rect(-9 * scale, -15 * scale, (unit.battery / 1800) * 18 * scale, 4 * scale);
    pop();
  } else if (unit.type === 'turret') {
    push();
    translate(unit.x, unit.y);
    let target = findNearestEnemyDrone(unit) || findNearestPlayerDrone(unit);
    let angle = target ? Math.atan2(target.y - unit.y, target.x - unit.x) : 0;
    fill(unit.cooldown > 0 ? color(120, 120, 120) : col);
    rect(-10 * pulse * scale, -10 * pulse * scale, 20 * pulse * scale, 20 * pulse * scale);
    if (unit.cooldown <= 0 && target && dist(unit.x, unit.y, target.x, target.y) < min(cellWidth, cellHeight) * 2.5) {
      target.health -= 50;
      unit.cooldown = 300;
      shotEffects.push({
        startX: unit.x,
        startY: unit.y,
        endX: target.x,
        endY: target.y,
        color: col,
        timer: 5
      });
      if (target.health <= 0) {
        if (col.levels[1] === 255) gold += 20;
        else enemyGold += 20;
      }
    }
    pop();
  } else if (unit.type === 'city') {
    push();
    translate(unit.x, unit.y);
    fill(col);
    beginShape();
    for (let i = 0; i < 6; i++) {
      let angle = TWO_PI / 6 * i;
      vertex(20 * pulse * scale * cos(angle), 20 * pulse * scale * sin(angle));
    }
    endShape(CLOSE);
    pop();
  } else if (unit.type === 'bunker') {
    push();
    translate(unit.x, unit.y);
    fill(col);
    beginShape();
    for (let i = 0; i < 6; i++) {
      let angle = TWO_PI / 6 * i;
      vertex(15 * pulse * scale * cos(angle), 15 * pulse * scale * sin(angle));
    }
    endShape(CLOSE);
    pop();
  }
}

function findNearestEnemyDrone(unit) {
  let closest = null;
  let minDist = Infinity;
  enemyUnits.forEach(e => {
    if (e.type === 'drone') {
      let d = dist(unit.x, unit.y, e.x, e.y);
      if (d < minDist) {
        minDist = d;
        closest = e;
      }
    }
  });
  return closest;
}

function findNearestPlayerDrone(unit) {
  let closest = null;
  let minDist = Infinity;
  playerUnits.forEach(p => {
    if (p.type === 'drone') {
      let d = dist(unit.x, unit.y, p.x, p.y);
      if (d < minDist) {
        minDist = d;
        closest = p;
      }
    }
  });
  return closest;
}

function moveUnit(unit) {
  if (!unit.stuckCounter) unit.stuckCounter = 0;
  let prevX = unit.x, prevY = unit.y;
  let target = findNearestEnemy(unit);
  let damage = 0.5;
  let nearestArmedTurret = null;
  let minDist = Infinity;
  enemyUnits.forEach(t => {
    if (t.type === 'turret' && t.cooldown <= 0) {
      let d = dist(unit.x, unit.y, t.x, t.y);
      if (d < minDist && d < min(cellWidth, cellHeight) * 2.5) {
        minDist = d;
        nearestArmedTurret = t;
      }
    }
  });
  let dx = 0, dy = 0;
  if (nearestArmedTurret) {
    let turretDist = dist(unit.x, unit.y, nearestArmedTurret.x, nearestArmedTurret.y) || 1;
    dx = (unit.x - nearestArmedTurret.x) / turretDist * 3 * (100 - turretDist) / 100;
    dy = (unit.y - nearestArmedTurret.y) / turretDist * 3 * (100 - turretDist) / 100;
    unit.x = constrain(unit.x + dx * 2, 0, width);
    unit.y = constrain(unit.y + dy * 2, 0, height);
  } else if (target && dist(unit.x, unit.y, target.x, target.y) < min(cellWidth, cellHeight) * 2.5) {
    let d = dist(unit.x, unit.y, target.x, target.y) || 1;
    dx = (target.x - unit.x) / d;
    dy = (target.y - unit.y) / d;
    if (d > min(cellWidth, cellHeight) * 0.25) {
      unit.x = constrain(unit.x + dx * 2, 0, width);
      unit.y = constrain(unit.y + dy * 2, 0, height);
    } else {
      target.health -= damage;
      if (target.health <= 0) {
        deathEffects.push({ x: target.x, y: target.y, type: 'explosion', stage: 0, timer: 10 });
        gold += target.type === 'city' ? 100 : target.type === 'bunker' ? 50 : 20;
        enemyGold += 20;
      }
    }
  } else {
    if (!unit.patrolTarget || dist(unit.x, unit.y, unit.patrolTarget.x, unit.patrolTarget.y) < min(cellWidth, cellHeight) * 0.25 || unit.stuckCounter > 10) {
      let validCells = [];
      for (let i = 0; i < gridRows; i++) {
        for (let j = 0; j < gridCols; j++) {
          if (terrain[i][j] !== 'R' && terrain[i][j] !== 'T' && !isUnitAtPosition(j * cellWidth + cellWidth / 2, i * cellHeight + cellHeight / 2)) {
            validCells.push({ x: j * cellWidth + cellWidth / 2, y: i * cellHeight + cellHeight / 2 });
          }
        }
      }
      unit.patrolTarget = validCells.length > 0 ? random(validCells) : { x: random(width), y: random(height) };
      unit.stuckCounter = 0;
    }
    if (unit.patrolTarget) {
      let distVal = dist(unit.x, unit.y, unit.patrolTarget.x, unit.patrolTarget.y) || 1;
      dx = (unit.patrolTarget.x - unit.x) / distVal;
      dy = (unit.patrolTarget.y - unit.y) / distVal;
      unit.x = constrain(unit.x + dx * 2, 0, width);
      unit.y = constrain(unit.y + dy * 2, 0, height);
    }
  }
  if (frameCount % 30 === 0) updateGrid(unit);
  if (Math.abs(unit.x - prevX) < 0.1 && Math.abs(unit.y - prevY) < 0.1) {
    unit.stuckCounter++;
    if (unit.stuckCounter > 10) {
      unit.patrolTarget = null;
      console.log(`Drone stuck: resetting patrolTarget at x=${unit.x}, y=${unit.y}`);
    }
  } else {
    unit.stuckCounter = 0;
  }
}

function moveEnemy(unit) {
  if (!unit.stuckCounter) unit.stuckCounter = 0;
  let prevX = unit.x, prevY = unit.y;
  let nearestArmedTurret = null;
  let minDist = Infinity;
  playerUnits.forEach(p => {
    if (p.type === 'turret' && p.cooldown <= 0) {
      let d = dist(unit.x, unit.y, p.x, p.y);
      if (d < minDist && d < min(cellWidth, cellHeight) * 2.5) {
        minDist = d;
        nearestArmedTurret = p;
      }
    }
  });
  let damage = 0.5;
  if (unit.type === 'drone') {
    if (nearestArmedTurret) {
      let turretDist = dist(unit.x, unit.y, nearestArmedTurret.x, nearestArmedTurret.y) || 1;
      let dx = (unit.x - nearestArmedTurret.x) / turretDist * 3 * (100 - turretDist) / 100;
      let dy = (unit.y - nearestArmedTurret.y) / turretDist * 3 * (100 - turretDist) / 100;
      unit.x = constrain(unit.x + dx * 2, 0, width);
      unit.y = constrain(unit.y + dy * 2, 0, height);
    } else {
      let target = findNearestPlayerUnit(unit);
      if (target && target.type !== 'turret' && dist(unit.x, unit.y, target.x, target.y) < min(cellWidth, cellHeight) * 2.5) {
        let distVal = dist(unit.x, unit.y, target.x, target.y) || 1;
        let dx = (target.x - unit.x) / distVal;
        let dy = (target.y - unit.y) / distVal;
        if (distVal > min(cellWidth, cellHeight) * 0.25) {
          unit.x = constrain(unit.x + dx * 2, 0, width);
          unit.y = constrain(unit.y + dy * 2, 0, height);
        } else {
          target.health -= damage;
          if (target.health <= 0) {
            deathEffects.push({ x: target.x, y: target.y, type: 'explosion', stage: 0, timer: 10 });
            enemyGold += target.type === 'city' ? 100 : target.type === 'bunker' ? 50 : 20;
          }
        }
      } else {
        if (!unit.patrolTarget || dist(unit.x, unit.y, unit.patrolTarget.x, unit.patrolTarget.y) < min(cellWidth, cellHeight) * 0.25 || unit.stuckCounter > 10) {
          let validCells = [];
          for (let i = 0; i < gridRows; i++) {
            for (let j = 0; j < gridCols; j++) {
              if (terrain[i][j] !== 'R' && terrain[i][j] !== 'T' && !isUnitAtPosition(j * cellWidth + cellWidth / 2, i * cellHeight + cellHeight / 2)) {
                validCells.push({ x: j * cellWidth + cellWidth / 2, y: i * cellHeight + cellHeight / 2 });
              }
            }
          }
          unit.patrolTarget = validCells.length > 0 ? random(validCells) : { x: random(width), y: random(height) };
          unit.stuckCounter = 0;
        }
        if (unit.patrolTarget) {
          let distVal = dist(unit.x, unit.y, unit.patrolTarget.x, unit.patrolTarget.y) || 1;
          let dx = (unit.patrolTarget.x - unit.x) / distVal;
          let dy = (unit.patrolTarget.y - unit.y) / distVal;
          unit.x = constrain(unit.x + dx * 2, 0, width);
          unit.y = constrain(unit.y + dy * 2, 0, height);
        }
      }
    }
    if (frameCount % 30 === 0) updateEnemyGrid(unit);
    if (Math.abs(unit.x - prevX) < 0.1 && Math.abs(unit.y - prevY) < 0.1) {
      unit.stuckCounter++;
      if (unit.stuckCounter > 10) {
        unit.patrolTarget = null;
        console.log(`Enemy drone stuck: resetting patrolTarget at x=${unit.x}, y=${unit.y}`);
      }
    } else {
      unit.stuckCounter = 0;
    }
  }
}

function findNearestEnemy(unit) {
  let closest = null;
  let minDist = Infinity;
  enemyUnits.forEach(e => {
    let d = dist(unit.x, unit.y, e.x, e.y);
    if (d < minDist) {
      minDist = d;
      closest = e;
    }
  });
  return closest;
}

function findNearestPlayerUnit(unit) {
  let closest = null;
  let minDist = Infinity;
  playerUnits.forEach(p => {
    if (p.type !== 'turret') {
      let d = dist(unit.x, unit.y, p.x, p.y);
      if (d < minDist) {
        minDist = d;
        closeness = p;
      }
    }
  });
  return closest;
}

function updateGrid(unit) {
  let gridX = Math.floor(unit.x / cellWidth);
  let gridY = Math.floor(unit.y / cellHeight);
  if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows && grid[gridY][gridX] === 'enemy') {
    for (let di of [-1, 0, 1]) {
      for (let dj of [-1, 0, 1]) {
        if (Math.abs(di) + Math.abs(dj) === 1) {
          let ni = gridY + di, nj = gridX + dj;
          if (ni >= 0 && ni < gridRows && nj >= 0 && nj < gridCols && grid[ni][nj] === 'player') {
            grid[gridY][gridX] = 'player';
            controlledCells = Math.min(Math.floor(controlledCells + 1), totalCells);
            return;
          }
        }
      }
    }
  }
}

function updateEnemyGrid(unit) {
  let gridX = Math.floor(unit.x / cellWidth);
  let gridY = Math.floor(unit.y / cellHeight);
  if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows && grid[gridY][gridX] === 'player') {
    for (let di of [-1, 0, 1]) {
      for (let dj of [-1, 0, 1]) {
        if (Math.abs(di) + Math.abs(dj) === 1) {
          let ni = gridY + di, nj = gridX + dj;
          if (ni >= 0 && ni < gridRows && nj >= 0 && nj < gridCols && grid[ni][nj] === 'enemy') {
            grid[gridY][gridX] = 'enemy';
            controlledCells = Math.max(Math.floor(controlledCells - 1), 0);
            return;
          }
        }
      }
    }
  }
}

function generateGold() {
  if (frameCount % 60 === 0) {
    gold += Math.floor(controlledCells / 8) + 5;
    enemyGold += Math.floor((totalCells - controlledCells) / 8) + 5;
    let maxSpawns = 2;
    let spawns = 0;
    let adjustedDroneProb = enemyUnits.length > 10 ? enemySpawnProbs.drone * 0.7 : enemySpawnProbs.drone;
    if (enemyUnits.length < 15) {
      while (enemyGold >= 40 && spawns < maxSpawns && enemyUnits.length < 15) {
        if (random() < adjustedDroneProb && enemyGold >= 40) {
          enemyGold -= 40;
          spawnEnemy('drone');
          spawns++;
        } else if (enemyGold >= 200) {
          enemyGold -= 200;
          spawnEnemy('turret');
          spawns++;
        }
      }
    }
    if (enemyGold >= 500 && controlledCells > 0.5 * totalCells) {
      let playerCells = [];
      for (let i = 0; i < gridRows; i++) {
        for (let j = 0; j < gridCols; j++) {
          if (grid[i][j] === 'player') playerCells.push({ x: j * cellWidth + cellWidth / 2, y: i * cellHeight + cellHeight / 2 });
        }
      }
      if (playerCells.length > 0) {
        let target = random(playerCells);
        let enemyCity = enemyUnits.find(u => u.type === 'city');
        if (enemyCity) {
          enemyGold -= 500;
          missileEffects.push({ type: 'trajectory', startX: enemyCity.x, startY: enemyCity.y, endX: target.x, endY: target.y, timer: 10 });
          missileEffects.push({ type: 'explosion', x: target.x, y: target.y, stage: 0, timer: 20 });
          playerUnits = playerUnits.filter(u => {
            if (dist(u.x, u.y, target.x, target.y) < min(cellWidth, cellHeight) && u.type !== 'city') {
              playerUnitsDestroyed++;
              return false;
            }
            return true;
          });
          enemyUnits = enemyUnits.filter(u => {
            if (dist(u.x, u.y, target.x, target.y) < min(cellWidth, cellHeight)) {
              enemyUnitsDestroyed++;
              return false;
            }
            return true;
          });
        }
      }
    }
  }
}

function updateUI() {
  document.getElementById('gold').innerText = Math.floor(gold);
  document.getElementById('enemyGold').innerText = Math.floor(enemyGold);
  document.getElementById('area').innerText = ((controlledCells / totalCells) * 100).toFixed(1) + '%';
  document.getElementById('status').innerText = gameStatus;
  document.getElementById('playerDrones').innerText = playerUnits.filter(u => u.type === 'drone').length;
  document.getElementById('playerTurrets').innerText = playerUnits.filter(u => u.type === 'turret').length;
  document.getElementById('playerUnitsDestroyed').innerText = playerUnitsDestroyed;
  document.getElementById('enemyUnitsDestroyed').innerText = enemyUnitsDestroyed;
  document.getElementById('action-indicator').innerText = inputActive && inputStartTime ? (grid[Math.floor(inputY / cellHeight)][Math.floor(inputX / cellWidth)] === 'enemy' ? 'Preparing missile...' : (millis() - inputStartTime > 200 ? 'Holding for turret...' : '')) : '';
}

function checkGameStatus() {
  if (controlledCells >= totalCells && gameStatus === 'Playing') {
    gameStatus = 'Victory!';
    console.log('Game stopped: All cells captured by player');
    setTimeout(() => {
      recordGameOutcome('player_win');
      noLoop();
    }, 2000);
  } else if (controlledCells <= 0 && gameStatus === 'Playing') {
    gameStatus = 'Defeat!';
    console.log('Game stopped: All cells lost');
    setTimeout(() => {
      recordGameOutcome('enemy_win');
      noLoop();
    }, 2000);
  }
}

function recordGameOutcome(outcome) {
  gameHistory.push({ 
    outcome, 
    playerCells: controlledCells, 
    playerTurrets: playerUnits.filter(u => u.type === 'turret').length,
    playerDrones: playerUnits.filter(u => u.type === 'drone').length,
    enemyTurrets: enemyUnits.filter(u => u.type === 'turret').length,
    enemyDrones: enemyUnits.filter(u => u.type === 'drone').length,
    playerGold: gold,
    enemyGold
  });
  updateEnemyStrategy();
}

function updateEnemyStrategy() {
  if (gameHistory.length > 0) {
    let lastRound = gameHistory[gameHistory.length - 1];
    let totalPlayerUnits = lastRound.playerTurrets + lastRound.playerDrones;
    let totalEnemyUnits = lastRound.enemyTurrets + lastRound.enemyDrones;
    if (lastRound.outcome === 'player_win') {
      if (lastRound.playerTurrets > totalPlayerUnits * 0.4) {
        enemySpawnProbs.turret = Math.min(enemySpawnProbs.turret + 0.1, 0.5);
        enemySpawnProbs.drone = Math.max(enemySpawnProbs.drone - 0.1, 0.5);
      }
      if (lastRound.playerDrones > totalPlayerUnits * 0.6) {
        enemySpawnProbs.turret = Math.min(enemySpawnProbs.turret + 0.05, 0.5);
        enemySpawnProbs.drone = Math.max(enemySpawnProbs.drone - 0.05, 0.5);
      }
      if (lastRound.playerGold > lastRound.enemyGold * 1.5) {
        enemyDroneHealth = Math.min(enemyDroneHealth + 10, 85);
      }
      if (lastRound.playerCells > totalCells * 0.75) {
        enemySpawnProbs.drone = Math.min(enemySpawnProbs.drone + 0.05, 0.7);
      }
    } else if (lastRound.outcome === 'enemy_win') {
      if (lastRound.enemyTurrets > totalEnemyUnits * 0.4) {
        enemySpawnProbs.turret = Math.max(enemySpawnProbs.turret - 0.05, 0.3);
        enemySpawnProbs.drone = Math.min(enemySpawnProbs.drone + 0.05, 0.7);
      }
      if (lastRound.playerCells < 100) {
        enemyDroneHealth = Math.max(enemyDroneHealth - 10, 65);
      }
      if (totalPlayerUnits > totalEnemyUnits * 1.5) {
        enemySpawnProbs.drone = Math.min(enemySpawnProbs.drone + 0.05, 0.7);
      }
    }
  }
}

function drawMap() {
  for (let i = 0; i < gridRows; i++) {
    for (let j = 0; j < gridCols; j++) {
      drawingContext.fillStyle = grid[i][j] === 'player' ? playerGradient : enemyGradient;
      rect(j * cellWidth, i * cellHeight, cellWidth, cellHeight);
    }
  }
  terrainCache.forEach(t => {
    if (t.type === 'R') {
      drawingContext.fillStyle = rockGradient;
      ellipse(t.x, t.y, min(cellWidth, cellHeight) * 0.5, min(cellWidth, cellHeight) * 0.5);
      fill(80, 80, 80);
      ellipse(t.x + min(cellWidth, cellHeight) * 0.125, t.y + min(cellWidth, cellHeight) * 0.125, min(cellWidth, cellHeight) * 0.25, min(cellWidth, cellHeight) * 0.25);
    } else if (t.type === 'T') {
      drawingContext.fillStyle = treeGradient;
      triangle(t.x, t.y - min(cellWidth, cellHeight) * 0.25, t.x - min(cellWidth, cellHeight) * 0.25, t.y + min(cellWidth, cellHeight) * 0.25, t.x + min(cellWidth, cellHeight) * 0.25, t.y + min(cellWidth, cellHeight) * 0.25);
      fill(139, 69, 19);
      rect(t.x - min(cellWidth, cellHeight) * 0.1, t.y + min(cellWidth, cellHeight) * 0.25, min(cellWidth, cellHeight) * 0.2, min(cellWidth, cellHeight) * 0.2);
    }
  });
  stroke(0, 0, 0, 60);
  strokeWeight(0.5);
  for (let i = 0; i <= gridRows; i++) {
    line(0, i * cellHeight, width, i * cellHeight);
  }
  for (let j = 0; j <= gridCols; j++) {
    line(j * cellWidth, 0, j * cellWidth, height);
  }
  noStroke();
  if (inputActive && gameStatus === 'Playing' && (touches.length > 0 || mouseIsPressed)) {
    let gridX = Math.floor(inputX / cellWidth);
    let gridY = Math.floor(inputY / cellHeight);
    let snappedX = gridX * cellWidth + cellWidth / 2;
    let snappedY = gridY * cellHeight + cellHeight / 2;
    if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows) {
      let holdDuration = inputStartTime ? millis() - inputStartTime : 0;
      let pulse = 1 + 0.1 * Math.sin(frameCount * 0.1);
      let scale = min(cellWidth, cellHeight) / 40;
      if (grid[gridY][gridX] === 'enemy') {
        fill(255, 0, 0, 60);
        ellipse(snappedX, snappedY, min(cellWidth, cellHeight) * 1.75 * pulse, min(cellWidth, cellHeight) * 1.75 * pulse);
      } else if (grid[gridY][gridX] === 'player' && !isUnitAtPosition(snappedX, snappedY) && terrain[gridY][gridX] !== 'R' && terrain[gridY][gridX] !== 'T') {
        let action = holdDuration > 500 ? 'turret' : 'drone';
        if (action === 'drone') {
          fill(255, 255, 0, 60);
          rect(gridX * cellWidth, gridY * cellHeight, cellWidth, cellHeight);
          push();
          translate(snappedX, snappedY);
          fill(255, 255, 0);
          ellipse(0, 0, 10 * pulse * scale, 10 * pulse * scale);
          let propSize = 5 * scale;
          let propOffset = 10 * scale;
          let propAngle = frameCount * 0.5;
          fill(150, 150, 150);
          for (let i = 0; i < 4; i++) {
            let propX = propOffset * cos(TWO_PI / 4 * i + propAngle);
            let propY = propOffset * sin(TWO_PI / 4 * i + propAngle);
            ellipse(propX, propY, propSize, propSize);
          }
          pop();
        } else if (action == 'turret' && isValidTurretPosition(snappedX, snappedY)) {
          fill(255, 255, 0, 60);
          rect(gridX * cellWidth, gridY * cellHeight, cellWidth, cellHeight);
          fill(255, 255, 0);
          rect(snappedX - 10 * pulse * scale, snappedY - 10 * pulse * scale, 20 * pulse * scale, 20 * pulse * scale);
        }
      }
    }
  }
}

function revertNonAdjacentCells() {
  let changes = 0;
  let playerCity = playerUnits.find(u => u.type === 'city');
  let cityX = playerCity ? Math.floor(playerCity.x / cellWidth) : Math.floor(gridCols * 0.1);
  let cityY = playerCity ? Math.floor(playerCity.y / cellHeight) : Math.floor(gridRows * 0.1);
  for (let i = 0; i < gridRows && changes < 30; i++) {
    for (let j = 0; j < gridCols && changes < 30; j++) {
      if (grid[i][j] === 'player') {
        let hasAdjacentPlayer = false;
        for (let di of [-1, 0, 1]) {
          for (let dj of [-1, 0, 1]) {
            if (Math.abs(di) + Math.abs(dj) === 1) {
              let ni = i + di, nj = j + dj;
              if (ni >= 0 && ni < gridRows && nj >= 0 && nj < gridCols && grid[ni][nj] === 'player') {
                hasAdjacentPlayer = true;
              }
            }
          }
        }
        // Prevent reverting cells near the player's city
        if (!hasAdjacentPlayer && !(Math.abs(i - cityY) <= 2 && Math.abs(j - cityX) <= 2)) {
          grid[i][j] = 'enemy';
          controlledCells = Math.max(Math.floor(controlledCells - 1), 0);
          changes++;
        }
      }
    }
  }
}
</script>
</body>
</html>
